\documentclass[a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{listings}
\lstloadlanguages{Python}
\usepackage[dvips]{graphicx}
\lstset{extendedchars=false,
        breaklines=true, 
        breakatwhitespace=true}


\begin{document}

\begin{titlepage}
    \newpage
    \begin{center}
        ЯРОСЛАВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ \\*
        \hrulefill
    \end{center}
    \vspace{8em}
    \begin{center}
        \Large Курсовая работа на тему:
    \end{center}
    \vspace{2.5em}
    \begin{center}
        \textsc{\textbf{\LARGE{исследование тензорных произведений матриц\linebreak
                                над конечным полем}}}
    \end{center}
    \vspace{6em}
    \vspace{\fill}
    \flushright{Исполнил: Бедняков А.И.}
    \flushright{Науч. рук.: Казарин Л.С.}
    \begin{center}
        Ярославль, 2011. 
    \end{center}
\end{titlepage}

\section*{Постановка задачи}
    В курсовой работе рассматривается проблема скорости умножения матриц с использованием результатов тензорного исчисления. Если задано конечное поле Галуа $GF(q)$, то на нем можно построить множества квадратных матриц порядка $m$ - $GL_m(q)$ и порядка $n$ - $GL_n(q)$. 
    Определим для каждого $A \in GL_m(q)$ {\bf показатель} ({\bf мультипликативный порядок}) - наименьшее положительное число $\ell$ такое, что $A^\ell \equiv \varepsilon \pmod q$, где $\varepsilon$ - единичная матрица порядка $m$. 
    Аналогично, $(\forall B \in GL_n(q)) : (\exists \min \ell \in \mathcal{N}) : B^\ell \equiv \varepsilon \pmod q$. 

    Тогда элементы из $GL_m(q)$ имеют максимальный мультипликативный порядок $q^m-1$, а элементы из $GL_n(q)$ порядок $q^n-1$.

    Также определим отображение $M_m \times M_n \rightarrow M_{mn}$, называемое {\bfтензорным произведением}:
    \begin{equation}\label{eq:tensor_product}
        \mathrm{A} \otimes \mathrm{B} = 
        \begin{pmatrix} 
            a_{11}B & \cdots & a_{1n}B \\ 
            \vdots & \ddots & \vdots \\ 
            a_{m1} B & \cdots & a_{mn} B 
        \end{pmatrix} 
    \end{equation}
    Это отображение, перенесенное на ранее определенные множества $GL_m(q)$ и $GL_n(q)$ даст новую структуру: $GL_m(q) \times GL_n(q) \rightarrow GL_{mn}(q)$. 
    Очевидно, изменится и мультипликативный порядок, который будет равен НОК$(q^m-1,q^n-1)<q^{m+n}-1$. Является ли эта оценка максимальной? 
    Оказывавется, нет - в статье [1] приводится теорема, основываясь на которой можно сказать, что если числа $m$ и $n$ не взаимнопросты, то максимальный мультипликативный порядок элемента из $GL_{mn}(q)i \leq \max\{q^{mn-n+1},q{mn-m+1}\}q^r$, где $r=\max\{\log_q{nq},\log_p{mq}\}$. А, по той же теореме, если числа $m$ и $n$ взаимно просты, то максимальный порядок равен $q^{st}-1$.
    К тому же, оценка уменьшается при разбиении чисел $s$ или $t$ на слагаемые числом более двух. Следовательно, наибольший мультипликативный порядок элемента из $GL_{mn}(q)$ только при разбиении на 2 слагаемых.

    Но выполнение условия $(n,m)=1$ не дает автоматически матрицу имеющую максимальный возможный порядок $q^{st}-1$. 
    Полученная матрица $C=\sum _{i=1} ^2 A_i \otimes B_i$ порядка НОК$(q^m-1,q^n-1)$, рассматриваемая как элемент $GF(q^{st})$ имеет многочлен степени $st$. Причем примитивный элемент будет являться комбинацией степеней $C$.


    В итоге, известно что для любой $C \in GL_{mn}(q)$ с известным мультипликативным порядком можно построить такие $A_i \in GL_m(q)$ и $B_i \in GL_n(q)$, что 
    \begin{equation}\label{eq:main_sum}
        \sum \limits_{i=1}^{2} 
        \underbrace{A_i}_{n\times n}
        \otimes 
        \underbrace{B_i}_{n\times n} = 
        \underbrace{C}_{mn\times mn}.
    \end{equation}

    На практике такие построения пригождаются в криптографии. Сердце поточного шифра - гамма. Последовательность чисел, используя которую криптоалгоритм преобразует исходный текст в шифр и обратно. Слишком короткая даст оппоненту возможность подбора. 
    Логично генерировать случайные гаммы длинной равные исходному сообщению, но тогда возникает необходимость передавать их вместе с шифром, что кроме двойной избыточности создает возможность перехвата. 
    Одним из выходов из этой ситуации - рекуррентные последовательности. называется всякая числовая рекуррентная последовательность $x_0,x_1,\dots$, задаваемая линейным рекуррентным соотношением: $x_k=\sum_{i=1}^na_ix_{k-i}$ при $k\geqslant n$ с заданными начальными членами $x_0,\dots,x_{n-1}$, где $n$ — фиксированное натуральное число, $a_1,\dots,a_n$ — заданные числовые коэффициенты, $a_n\ne 0$. 
    При этом число n называется порядком последовательности. 
    В работе [2] на стр. 2 описан способ обращения с $C$ как с сопровождающей матрицей преобразования, т.е. использование ее вместо рекуррентного соотношения при получении из последовательности $X^{(n-1)}=x_0,\dots,x_{n-1}$ последовательности $X^{(n)}=x_1,\dots,x_{n}$. 
    Из этого следует, что получение нового члена последовательности эквивалентно единоразовому умножению на $C$ ($C^{m} \cdot X^{(n-1)} = X^{(n+m)}$), а значит длина рекуррентности напрямую зависит от мультипликативного порядка.
    Итак, приведенную выше формулу (2) можно интерпретировать как
    \begin{equation}\label{eq:deriv_sum}
        X^{(n)} = \sum \limits_{i=1}^{t} A_i X^{(n-1)} B_i 
    \end{equation}
    в которой, в свою очередь, возможно рассматривать $X^{(n)}$ как результат умножения матрицы $\sum_{i=1}^{t} A_i \otimes B_i$ (т.е. искомой матрицы $C$ из уравнения (1)) на вектор $X^{(n-1)}$. Зачем?
    Изначально, умножение вектора $(X^{(n-1)})^t$ размера $mn$ на матрицу $C$ занимало $mn$ операций $mn$ раз, итого $(mn)^2$. Теперь нужно лишь $AX^{(n-1)}B^t$ что займет $mn^2+nm^2 = mn(m+n)$ плюс накладные на поиск, что в сумме не перевесит изначального квадрата произведения.

\section*{Изучение задачи}
    Изначальная задача поиска порядка матриц $A$ и $B$ из произведения $C=\sum _{i=1} ^2 A_i \otimes B_i$ сводится к

    {\bf Подзадача.} Для заданного числа $k$ найти пары чисел $m$ и $n$, такие что $k=m+n$ и НОД$(n,m)=1$.

    \subsubsection*{Алгоритм Евклида}
    Решение будет оформлено на Python, как на одном из самых лаконичных языков. 
    Вот, например, необходимый нам алгоритм поиска НОД (или GCD):
    \lstinputlisting{euclid.py}
    Пока b не нулевое, выполняем цикл - заменяя переменную a тем, чтобыло в b, в которую перекладываем остаток от деления.
    Как только b обнуляется - мы получаем НОД в a.

    \subsubsection*{Поиск}
    Возьмем значение $k$ у пользователя и будем перебирать пары $k, k-i$. 
    Запишем это стандартным путем:
    \lstinputlisting{find.py}
    Все хорошо, но объект range() формирует список из указанных в скобках чисел, что не только отнимает память, но и ограничивает размеры возможных результатов до уровня встроенной переменной int.

    \subsubsection*{Итоговый алгоритм}
    Поэтому мы перепишем алгоритм как вечный цикл, который ломается при переходе $k$ в отрицательные,
    \lstinputlisting{algo.py}
    и получим алгоритм, ограничением для которого является только память компьютера.

\includegraphics[width=1\linewidth]{test.eps}
    


\begin{thebibliography}{99}
    \bibitem{main} Казарин Л.С., Сидельников В.М., ``Алгебры $\mathcal{A}_m$ и их использование в криптографии II.'', 2008.
    \bibitem{linear} Кострикин А.И., ``Введение в алгебру. Часть II. Основы алгебры.'', гл. 6: Тензоры, ФИЗМАТЛИТ, 2000.
    \bibitem{another} Гусев М.Ю., ``Конечные поля и их использование в криптографии.'', ЯРГУ, 2011.
    \bibitem{tensor} Гаврилов С.К., ``Тензорное исчисление'', 2007.
    \bibitem{kroneker} Малозёмов В.Н., Просеков  О.В., ``Кронекерово умножение матриц и коммутативность'', Секция «Дискретный гармонический анализ», СпбУ, 31 марта 2004 г.
\end{thebibliography}

\end{document} 

